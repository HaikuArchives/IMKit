# Main build rules

# Executable <name> : <sources> : <libraries> : <res> ;
rule Executable
{
	AddResources $(1) : $(4) ;
	Main $(1) : $(2) ;
	LinkAgainst $(1) : $(3) ;
	LINKFLAGS on $(1) = [ on $(1) return $(LINKFLAGS) ]
		-Xlinker -soname=_APP_  ;
}

# Addon <target> : <sources> : <libraries> : <res> : <is executable> ;
# <target>: The add-on.
# <sources>: Source files.
# <libraries>: Libraries to be linked against.
# <res>: Resources.
# <isExecutable>: true, if the target shall be executable as well.
rule Addon target : sources : libraries : res : isExecutable
{
	AddResources $(target) : $(res) ;
	Main $(target) : $(sources) ;

	local linkFlags = -Xlinker -soname=\"$(target:G=)\" ;
	if $(isExecutable) != true {
		linkFlags = -nostart $(linkFlags) ;
	}
	LINKFLAGS on $(target) = [ on $(target) return $(LINKFLAGS) ] $(linkFlags) ;
	LinkAgainst $(target) : $(libraries) ;
}

# Translator <target> : <sources> : <libraries> : <isExecutable> ;
rule Translator target : sources : libraries : isExecutable
{
	Addon $(target) : $(sources) : $(libraries) : $(isExecutable) ;
}

# ScreenSaver <target> : <sources> : <libraries> ;
rule ScreenSaver target : sources : libraries
{
	Addon $(target) : $(sources) : $(libraries) : false ;
}

# StaticLibrary <lib> : <sources> : <otherObjects> ;
# Creates a static library from sources.
# <lib>: The static library to be built.
# <sources>: List of source files.
# <otherObjects>: List of additional object files.
rule StaticLibrary
{
	local lib = $(1) ;
	local sources = [ FGristFiles $(2) ] ;
	local otherObjects = $(3) ;
	local objects = $(sources:S=$(SUFOBJ)) ;

	MakeLocate $(<) : $(LOCATE_TARGET) ;
	StaticLibraryFromObjects $(lib) : $(objects) $(otherObjects) ;
	Objects $(2) ;
}

rule StaticLibraryFromObjects
{
	LibraryFromObjects $(1) : $(2) ;
}

# Ld <name> : <objs> : <linkerscript> : <flags> ;
rule Ld
{
	local target = $(1) ;
	local objects = $(2) ;
	local linkerScript = $(3) ;
	local linkerFlags = $(4) ;

	if $(linkerScript) {
		linkerFlags += --script=$(linkerScript) ;
	}

	on $(target) {
		LINKFLAGS on $(target) = $(linkerFlags) ;

		NEEDLIBS on $(target) = $(NEEDLIBS) ;
		LINKLIBS on $(target) = $(LINKLIBS) ;
	}

	LocalClean clean : $(target) ;
	LocalDepends all : $(target) ;
	Depends $(target) : $(objects) ;

	on $(1) XRes $(1) : $(RESFILES) ;
	SetType $(1) ;
	MimeSet $(1) ;
	SetVersion $(1) ;
}

actions Ld
{
	$(LINK) $(LINKFLAGS) -o "$(1)" "$(2)" "$(NEEDLIBS)" $(LINKLIBS)
}

# SharedLibraryFromObjects <lib> : <objects> : <libraries> ;
rule SharedLibraryFromObjects
{
	local _lib = $(1) ;

	MainFromObjects $(_lib) : $(2) ;
	LINKFLAGS on $(_lib) = [ on $(_lib) return $(LINKFLAGS) ]
		-nostart -Xlinker -soname=\"$(_lib:G=)\" ;
	LinkAgainst $(_lib) : $(3) ;
}

# SharedLibrary <lib> : <sources> : <libraries> ;
rule SharedLibrary
{
	local lib = $(1) ;
	local sources = [ FGristFiles $(2) ] ;
	local objects = $(sources:S=$(SUFOBJ)) ;
	local libs = $(3) ;

	Objects $(sources) ;
	SharedLibraryFromObjects $(lib) : $(objects) : $(libs) ;
}

# LinkAgainst <name> : <libs> [ : <mapLibs> ] ;
# Valid elements for <libs> are e.g. "be" or "libtranslation.so" or
# "/boot/.../libfoo.so". If the basename starts with "lib" or the thingy
# has a dirname or grist, it is added to the NEEDLIBS variable (i.e. the
# file will be bound!), otherwise it is prefixed "-l" and added to
# LINKLIBS. If you want to specify a target that isn't a library and
# also has neither grist nor a dirname, you can prepend "<nogrist>" as
# grist; it will be stripped by this rule.
# <mapLibs> specifies whether the to translate library names (e.g. "be"
# to "libbe.so"). Defaults to "true".
rule LinkAgainst
{
	local target = $(1) ;
	local libs = $(2) ;
	local mapLibs = $(3:E=true) ;

	on $(target) {
		# map libraries, if desired
		if $(mapLibs) = true
				&& $(TARGET_LIBRARY_NAME_MAP) {
			local mappedLibs ;

			for i in $(libs) {
				local mapped = $($(TARGET_LIBRARY_NAME_MAP)_$(i)) ;
				mapped ?= $(i) ;
				mappedLibs += $(mapped) ;
			}

			libs = $(mappedLibs) ;
		}

		local linkLibs ;
		local needLibs ;

		for i in $(libs)
		{
			local isfile = ;
			if $(i:D) || $(i:G) {
				isfile = true ;
				if $(i:G) = <nogrist> {
					i = $(i:G=) ;
				}
			} else {
				switch $(i:B)
				{
					# XXX: _APP_ and _KERNEL_ should not be needed for ELF.
					case _APP_ : isfile = true ;
					case _KERNEL_ : isfile = true ;
					case lib*	: isfile = true ;
					case *	: isfile = ;
				}
				if ! $(isfile) && ( $(i:S) = .so || $(i:S) = .a ) {
					isfile = true ;
				}
			}

			if $(isfile) {
				needLibs += $(i) ;
			} else {
				linkLibs += $(i) ;
			}
		}

		NEEDLIBS on $(1) = $(NEEDLIBS) $(needLibs) ;
		LINKLIBS on $(1) = $(LINKLIBS) -l$(linkLibs) ;

		if $(needLibs) && ! $(NO_LIBRARY_DEPENDENCIES) {
			Depends $(1) : $(needLibs) ;
		}
	}
}

# AddResources <name> : <resourcefiles> ;
rule AddResources
{
	# add grist to the resource files which don't have any yet
	local resfiles ;
	local file ;
	for file in $(2) {
		if ! $(file:G) {
			file = [ FGristFiles $(file) ] ;
		}
		resfiles += $(file) ;
	}

	SEARCH on $(resfiles) += $(SEARCH_SOURCE) ;

	for file in $(resfiles) {
		if $(file:S) = .rdef {
			local rdef = $(file) ;
			file = $(rdef:S=.rsrc) ;
			ResComp $(file) : $(rdef) ;
		}
		RESFILES on $(1) += $(file) ;
	}
}

# Overridden Jam rules

# Override to change permissions.
rule InstallLib
{
	InstallInto $(<) : $(>) ;
	MODE on $(>:G=$(INSTALLGRIST)) = $(EXEMODE) ;
}

# Overridden to use copyattr instead of cp and
# to allow spaces in file names.
actions Install
{
	$(COPYATTR) -d "$(>)" "$(<)"
}

# Overridden to allow spaces in file names.
actions Chmod1
{
	$(CHMOD) "$(MODE)" "$(1)"
}

# Overridden to allow spaces in file names.
actions piecemeal together existing Clean
{
	$(RM) "$(>)"
}

#-------------------------------------------------------------------------------
# Link rule/action are overwritten as they don't handle linking files who's name 
# contain spaces very well. Also adds resources and version to executable.
#-------------------------------------------------------------------------------
rule Link
{
	MakeLocate $(<) : $(LOCATE_TARGET) ;

 	NEEDLIBS on $(1) = [ on $(1) return $(NEEDLIBS) ] ;
 	LINKLIBS on $(1) = [ on $(1) return $(LINKLIBS) ] ;
	LINKFLAGS on $(1) += -fno-undefined ;

	MODE on $(<) = $(EXEMODE) ;
	on $(1) XRes $(1) : $(RESFILES) ;
	if ! [ on $(1) return $(DONT_USE_BEOS_RULES) ] {
		SetType $(<) ;
		MimeSet $(<) ;
		SetVersion $(<) ;
	}
	Chmod $(<) ;
}

actions Link bind NEEDLIBS
{
	$(LINK) $(LINKFLAGS) -o "$(<)" $(UNDEFS) "$(>)" $(NEEDLIBS) $(LINKLIBS) ;
}

# Force recreation of the archive to avoid build errors caused by
# stale dependencies after renaming or deleting object files.
actions together Archive
{
	$(RM) $(<)
	$(AR) $(<) $(>)
}

rule Library
{
	local lib = $(1) ;
	local sources = [ FGristFiles $(2) ] ;
	local objects = $(sources:S=$(SUFOBJ)) ;

	LibraryFromObjects $(lib) : $(objects) ;
	Objects $(sources) ;
}

rule LibraryFromObjects
{
	local _i _l _s ;

	# Add grist to file names
	# bonefish: No, don't. The Library rule does that anyway, and when we
	# have an object from another dir, we certainly don't want that.

	_s = $(>) ;
	_l = $(<:S=$(SUFLIB)) ;

	on $(_l) {
		# library depends on its member objects
	
		if $(KEEPOBJS)
		{
			LocalDepends obj : $(_s) ;
		}
	
		LocalDepends lib : $(_l) ;
	
		# Set LOCATE for the library and its contents.  The bound
		# value shows up as $(NEEDLIBS) on the Link actions.
		# For compatibility, we only do this if the library doesn't
		# already have a path.
	
		if ! $(_l:D)
		{
			# locate the library only, if it hasn't been located yet
			local dir = $(LOCATE[1]) ;
			if ! $(dir) {
				dir = [ on $(_l) return $(LOCATE[1]) ] ;
					# Note: The "on ..." is necessary, since our environment
					# isn't changed by MakeLocateDebug.
			}
			MakeLocate $(_l)($(_s:BS)) : $(dir) ;
		}
	
		if $(NOARSCAN) 
		{ 
			# If we can't scan the library to timestamp its contents,
			# we have to just make the library depend directly on the
			# on-disk object files.  
	
			Depends $(_l) : $(_s) ;
		}
		else
		{
			# If we can scan the library, we make the library depend
			# on its members and each member depend on the on-disk
			# object file.
	
			Depends $(_l) : $(_l)($(_s:BS)) ;
	
			for _i in $(_s)
			{
			Depends $(_l)($(_i:BS)) : $(_i) ;
			}
		}
	
		LocalClean clean : $(_l) ;
	
		# bonefish: Not needed on the supported platforms. Maybe later...
		# if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }
	
		Archive $(_l) : $(_s) ;
	
		if $(RANLIB) { Ranlib $(_l) ; }
	
		# If we can't scan the library, we have to leave the .o's around.
	
		if ! ( $(KEEPOBJS) || $(NOARSCAN) || $(NOARUPDATE) ) {
			RmTemps $(_l) : $(_s) ;
		}
	}
}

rule Main
{
	local target = $(1) ;
	local sources = [ FGristFiles $(2) ] ;
	local objects = $(sources:S=$(SUFOBJ)) ;

	MainFromObjects $(target) : $(objects) ;
	Objects $(sources) ;
}

rule MainFromObjects
{
	local _s _t ;

	# Add grist to file names
	# Add suffix to exe

	_s = [ FGristFiles $(>) ] ;
	_t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;

	# so 'jam foo' works when it's really foo.exe

	if $(_t) != $(<)
	{
	    Depends $(<) : $(_t) ;
	    NotFile $(<) ;
	}

	# make compiled sources a dependency of target

	LocalDepends exe : $(_t) ;
	Depends $(_t) : $(_s) ;

	LocalClean clean : $(_t) ;

	Link $(_t) : $(_s) ;
}

# Override Jam 2.5rc3 MakeLocate and MkDir to deal more intelligently
# with grist set on the supplied directory name.
rule MakeLocate
{
	local dir = $(2[1]) ;

	if $(dir)
	{
		if ! $(dir:G) {
			dir = $(dir:G=dir) ;
		}
	    LOCATE on $(1) += $(dir:G=) ;	# don't relocate once located
	    Depends $(1) : $(dir) ;
	    MkDir $(dir) ;
	}
}

rule MkDir
{
	local dir = $(<) ;
	if ! $(dir:G) {
		dir = $(dir:G=dir) ;
	}

	# make this and all super directories
	while true {
		# If dir exists, don't update it
		# Do this even for $(DOT).
		NoUpdate $(dir) ;

		# Bail out when reaching the CWD (".") or a directory we've already
		# made.
		if $(dir:G=) = $(DOT) || $($(dir:G=)-mkdir) {
			return ;
		}

		local s ;

		# Cheesy gate to prevent multiple invocations on same dir
		# MkDir1 has the actions 
		# Arrange for jam dirs

		$(dir:G=)-mkdir = true ;
		MkDir1 $(dir) ;
		LocalDepends dirs : $(dir) ;

		# Recursively make parent directories.
		# $(dir:P) = $(dir)'s parent, & we recurse until root

		s = $(dir:P) ;	# parent keeps grist
	
		if $(s:G=) && $(s) != $(dir) {
			Depends $(dir) : $(s) ;
			dir = $(s) ;
		} else if $(s) {
			NotFile $(s) ;
			break ;
		}
	}
}

rule ObjectCcFlags
{
	# supports inheriting the global variable value

	local file ;
	for file in [ FGristFiles $(1:S=$(SUFOBJ)) ] {
		CCFLAGS on $(file) = [ on $(file) return $(CCFLAGS) ] $(2) ;
	}
}

rule ObjectC++Flags
{
	# supports inheriting the global variable value

	local file ;
	for file in [ FGristFiles $(1:S=$(SUFOBJ)) ] {
		C++FLAGS on $(file) = [ on $(file) return $(C++FLAGS) ] $(2) ;
	}
}

rule ObjectDefines
{
	# supports inheriting the global variable value and multiple files

	if $(2) {
		local file ;
		for file in [ FGristFiles $(1:S=$(SUFOBJ)) ] {
			DEFINES on $(file) = [ on $(file) return $(DEFINES) ] $(2) ;
			CCDEFS on $(file) = [ on $(file) FDefines $(DEFINES) ] ;
		}
	}
}
